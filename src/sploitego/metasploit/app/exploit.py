#!/usr/bin/env python

from PyQt4.QtCore import SIGNAL
from PyQt4.QtGui import QMainWindow, QLineEdit, QLabel, QCheckBox, QComboBox, QSpinBox, QMessageBox
from time import sleep
from re import sub

from ui.exploit import Ui_MainWindow
from sploitego.metasploit.msfrpc import MsfRpcClient


class Window(QMainWindow, Ui_MainWindow):

    def __init__(self, password, exploit, rhost, rport, parent=None, **kwargs):
        QMainWindow.__init__(self, parent)
        self.rport = rport
        self.rhost = rhost
        self.sessionid = -1
        self.setupUi(self)
        self._msfInit(password, exploit, **kwargs)
        self._setDescription()
        self._populatePages()
        self._createTargetComboBox()
        self._createPayloadComboBox()

    def _msfInit(self, password, exploit, **kwargs):
        self.rpc = MsfRpcClient(password, **kwargs)
        self.m = self.rpc.modules
        self.e = self.m.use('exploit', exploit)
        self.setWindowTitle(self.e.name)

    def _setDescription(self):
        d = sub(r'\t+', '', self.e.description)
        d = sub(r'([^\n])\n([^\n])', r'\1 \2', d).strip(' ').strip('\n')
        self.descriptionLabel.setText(d)

    def _populatePages(self):
        self.e.optioninfo('RHOST')['default'] = self.rhost
        self.e.optioninfo('RPORT')['default'] = self.rport
        for i in self.e.options:
            o = self.e.optioninfo(i)
            page = self.requiredOptionsPage
            layout = self.requiredFormLayout
            if o['evasion']:
                page = self.evasionOptionsPage
                layout = self.evasionFormLayout
            elif o['advanced']:
                page = self.advancedOptionsPage
                layout = self.advancedFormLayout
            self._populate(page, layout, i, o)
        self.connect(self.exploitCommandLinkButton, SIGNAL('clicked(bool)'), self.exploit)

    def exploit(self, checked):
        j = None
        try:
            j = self.e.execute(payload=self.p)
        except TypeError, e:
            qmb = QMessageBox()
            qmb.setWindowTitle('Error!')
            qmb.setText(str(e))
            qmb.exec_()
            return
        self.hide()
        if j['job_id'] is not None:
            while j['job_id'] in self.rpc.jobs.list:
                sleep(1)
            timeout = self.e.runoptions.get('ConnectTimeout', 10)
            for i in range(timeout/2):
                sessions = self.rpc.sessions.list
                for k in sessions:
                    if sessions[k]['exploit_uuid'] == j['uuid']:
                        self.sessionid = k
                sleep(2)
        self.close()


    def _createTargetComboBox(self):
        self.targetComboBox = self._populate(
            self.requiredOptionsPage,
            self.requiredFormLayout,
            'TARGET',
            {
                'default': 0,
                'type' : 'targets',
                'enums' : self.e.targets,
                'required' : True
            },
            SIGNAL('currentIndexChanged(int)'),
            self._targetChanged
        )[1]

    def _createPayloadComboBox(self):
        ps = self.e.targetpayloads(0)

        self.payloadComboBox = self._populate(
            self.requiredOptionsPage,
            self.requiredFormLayout,
            'PAYLOAD',
            {
                'default': ps[0],
                'type': 'enum',
                'enums': ps,
                'required' : True
            },
            SIGNAL('currentIndexChanged(const QString &)'),
            self._payloadChanged
        )[1]

    def _payloadChanged(self, item):
        if not item:
            return

        self.p = self.m.use('payload', str(item))
        while self.payloadFormLayout.count():
            c = self.payloadFormLayout.takeAt(0)
            c.widget().deleteLater()

        for i in self.p.options:
            if i not in ['RHOST', 'WORKSPACE']:
                self._populate(
                    self.payloadGroupBox,
                    self.payloadFormLayout,
                    i,
                    self.p.optioninfo(i),
                    dataset=self.p
                )

    def _targetChanged(self, idx):
        if not hasattr(self, 'payloadComboBox'):
            return
        self.payloadComboBox.clear()
        for i,v in enumerate(self.e.targetpayloads(idx)):
            self.payloadComboBox.addItem(v, v)
        self.p['TARGET'] = idx

    def _populate(self, page, layout, name, opt, signal=None, action=None, dataset=None):
        label = '%s:' % name
        oval = opt.get('default', '')
        otype = opt['type']

        if dataset is None:
            dataset = self.e

        l = QLabel(page)
        l.setObjectName('%sLabel' % label.replace(' ', ''))
        l.setText(label)

        w = QLineEdit
        s = QLineEdit.setText

        if otype == 'bool':
            w = QCheckBox
            s = QCheckBox.setChecked
        elif otype in [ 'integer', 'port' ]:
            w = QSpinBox
            s = QSpinBox.setValue
            oval = int(oval) if oval else 0
        elif otype == 'enum':
            w = QComboBox
            def setter(obj, val):
                for i,v in enumerate(opt['enums']):
                    obj.addItem(v, v)
                obj.setCurrentIndex(obj.findText(val))
            s = setter
        elif otype == 'targets':
            w = QComboBox
            def setter(obj, val):
                for k in opt['enums']:
                    obj.addItem(opt['enums'][k], k)
                obj.setCurrentIndex(obj.findData(val))
            s = setter

        f = w(self.requiredOptionsPage)

        if otype == 'port':
            f.setRange(0, 65535)
        elif otype == 'integer':
            f.setMaximum(2 ** 31 - 1)

        if signal is not None and action is not None:
            self.connect(f, signal, action)
        elif isinstance(f, QLineEdit):
            def setData():
                qs = f.text()
                if not qs.isEmpty():
                    dataset[name] = str(qs)
                elif name in dataset:
                    del dataset[name]
            self.connect(f, SIGNAL('editingFinished()'), setData)
        elif isinstance(f, QSpinBox):
            def setData(i):
                dataset[name] = i
            self.connect(f, SIGNAL('valueChanged(int)'), setData)

        s(f, oval)
        f.setObjectName(name)
        if isinstance(f, QLineEdit):
            f.emit(SIGNAL('editingFinished()'))
        if 'desc' in opt:
            f.setToolTip(opt['desc'])
            l.setToolTip(opt['desc'])
        if opt['required']:
            l.setFont(self.boldFont)
        layout.addRow(l, f)
        return l, f

